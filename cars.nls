globals [carcount carsspawned]

breed [cars car]
cars-own[nextTarget lastTarget street 
        cognestion cognestion-time current-cognestion-time cognestion-count longest-cognestion
        birthtime]



to initcars
 create-cars 10
    ask cars [
    set size 0.75
    set color blue 
  ;  set shape "bettercar"
    let rndNode one-of nodes
    set xcor [xcor] of rndNode
    set ycor [ycor] of rndNode
 
    set cognestion false
    ifelse (count cars in-radius 0 = 1  ) [
      ifelse (one-of [out-link-neighbors] of rndNode = nobody) 
      [
        show "end. removing turtle." die
      ];else
      [
        set nextTarget one-of [out-link-neighbors] of rndNode
        set lastTarget [end1] of one-of ([my-in-links] of nextTarget)
        face nextTarget
      ]
    ];else
    [ 
      die
    ]
    set carcount ( count cars)
    set carsspawned carcount
  ]
end

to spawnCar
  let rndNode one-of nodes with [count in-link-neighbors = 0] with [count cars in-radius .3 = 0]
  ifelse (not (rndNode = nobody)) [
    create-cars 1 [
      set size 0.75
      set color blue
      set xcor [xcor] of rndNode
      set ycor [ycor] of rndNode
      set nextTarget one-of [out-link-neighbors] of rndNode
      set lastTarget [end1] of one-of ([my-in-links] of nextTarget)
      set street (link-of lastTarget nextTarget)
      face nextTarget
      set cognestion false
      set carcount (carcount + 1)
      set carsspawned (carsspawned + 1)
      set birthtime tickcount
      set hopCount 1
      set leader false
    ]
  ];else
  [
    show "all startnodes full"
  ]
end

to gocars
  ask cars [
    diecar
    ifelse (cars-ahead (heading) > 0)
    [
      ; Stau
      set leader false
      if (cognestion = false)[
        communicate heading
      ]
      stopcar
    ];else kein Stau
    [
      ifelse ( (d_euclidean poslst (pos-of nextTarget)) < .1 ) [
        ;Link ende erreicht
       ; let street (link-of lastTarget nextTarget)
        ifelse [is_light] of street [ 
          ;Link ist ampel
          ifelse [is_active] of street [
            ;die Ampel ist grÃ¼n
            updateTarget
            move  
          ];else die ampel ist rot
          [
            stopcar
          ]
        ];else Link ist keine Ampel
        [
          updateTarget
        ]
      ];else Linkende noch nicht erreicht
      [
        move
        set hopCount 1
        set leader true 
      ]
    ]
  ]
end


to move
  if (cognestion)[
    if longest-cognestion < current-cognestion-time [
      set longest-cognestion current-cognestion-time 
    ]
    set current-cognestion-time 0
  ]
  face nextTarget
  forward .1
  set color blue
  set cognestion false
end

to stopcar
  if (not cognestion) [
    set cognestion true
    set cognestion-count (cognestion-count + 1)
  ]
  set cognestion-time (cognestion-time + 1) 
  set current-cognestion-time ( current-cognestion-time + 1)
  set color orange
end

to updateTarget
  set lastTarget nextTarget
  set nextTarget one-of [out-link-neighbors] of nextTarget
  diecar
  set street (link-of lastTarget nextTarget)
end

to diecar
  if(nextTarget = nobody) [
      set carcount ( carcount - 1)
      log-car-death lastTarget cognestion-time cognestion-count longest-cognestion birthtime tickcount
      die
  ]
end

to communicate [myheading]
  tellJunction
  ask ( other cars with [heading < myheading + 20 AND heading > myheading - 20] in-cone .5 40 )[
    set hopCount (hopCount + 1)
    print hopCount
    communicate(heading) 
  ]
end

to tellJunction
  if (leader)[
    ;falls leder = true : setzte cogNr = hopCount
    ;die junktion 
   ; let a  street with part_of_junction)
    ask [part_of_junction] of street
        [
      set queue hopCount
      ;set queuepos [part_of_junction] of street
      
    ]   
  ]
  
end    
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



to-report nextcors [r phi]
 let x xcor + (r * sin (phi))
 let y ycor + (r * cos (phi))
 report list x y
end

to-report euclidean_distance[x1 y1 x2 y2]
  report sqrt ((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
end

to-report d_euclidean[p1 p2]
  report sqrt ((first p2 - first p1) ^ 2 + (last p2 - last p1) ^ 2)
end

to-report poslst
  report list xcor ycor
end

to-report pos-of [thing]
  report list ([xcor] of thing) ([ycor] of thing)
end

to-report cars-ahead [myheading]
  let c count other cars with [heading < myheading + 20 AND heading > myheading - 20] in-cone .5 40 
  let myxcor xcor
  let myycor ycor
  if (0 < count other cars with [xcor = myxcor and ycor = myycor])[
    set c 0
  ]
  report c 
end 

to-report link-of [lat nt]
  report one-of (links with [end1 = lat]) with [end2 = nt]
;   ([who] of lat) ([who] of nt)
end

 
  