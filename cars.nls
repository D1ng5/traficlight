globals [carcount carsspawned Lin Lout mescars summestimes ]

breed [cars car]
cars-own[nextTarget lastTarget street 
         hopCount leader
         cognestion cognestion-time current-cognestion-time cognestion-count longest-cognestion
         birthtime
         mes fo it ot
         ]

to initcars
 create-cars 10
    ask cars [
    set size 0.75
    set color blue 
  ;  set shape "bettercar"
    let rndNode one-of nodes
    set xcor [xcor] of rndNode
    set ycor [ycor] of rndNode
 
    set cognestion false
    ifelse (count cars in-radius 0 = 1  ) [
      ifelse (one-of [out-link-neighbors] of rndNode = nobody) 
      [
        show "end. removing turtle." die
      ];else
      [
        set nextTarget one-of [out-link-neighbors] of rndNode
        set lastTarget [end1] of one-of ([my-in-links] of nextTarget)
        face nextTarget
      ]
    ];else
    [ 
      die
    ]
    set carcount ( count cars)
    set carsspawned carcount
  ]
end

to spawnCar
  let rndNode one-of nodes with [count in-link-neighbors = 0] with [count cars in-radius .3 = 0]
  ifelse (not (rndNode = nobody)) [
    create-cars 1 [
      set size 0.75
      set color blue
      set xcor [xcor] of rndNode
      set ycor [ycor] of rndNode
      set nextTarget one-of [out-link-neighbors] of rndNode
      set lastTarget [end1] of one-of ([my-in-links] of nextTarget)
      set street (link-of lastTarget nextTarget)
      face nextTarget
      set cognestion false
      set carcount (carcount + 1)
      set carsspawned (carsspawned + 1)
      set birthtime tickcount
      set hopCount 1
      set leader false
      inittestcar
    ]
  ];else
  [
    show "all startnodes full"
  ]
end

to create-car-at [spawnNode]
  ifelse [count cars in-radius .3 = 0] of spawnNode [
    create-cars 1 [
      set size 0.75
      set color blue
      set xcor [xcor] of spawnNode
      set ycor [ycor] of spawnNode
      set nextTarget one-of [out-link-neighbors] of spawnNode
      set lastTarget [end1] of one-of ([my-in-links] of nextTarget)
      set street (link-of lastTarget nextTarget)
      face nextTarget
      set cognestion false
      set carcount (carcount + 1)
      set carsspawned (carsspawned + 1)
      set birthtime tickcount
      set hopCount 1
      set leader false
      inittestcar
    ]
  ]
  [
    print word "no space for creating a car at: " spawnNode
  ]
end

to gocars
  ask cars [
    if roadtests [testline]
    diecar
    ifelse (cars-ahead (heading) > 0)
    [
      ; Stau
      set leader false
      stopcar
    ];else kein Stau
    [
      ifelse ( (d_euclidean poslst (pos-of nextTarget)) < .1 ) [
        ;Link ende erreicht
        ; let street (link-of lastTarget nextTarget)
        ifelse [is_light] of street [ 
          ;Link ist ampel
          ifelse [is_active] of street [
            ;die Ampel ist grÃ¼n
            updateTarget
            move  
          ];else die ampel ist rot
          [
            stopcar
          ]
        ];else Link ist keine Ampel
        [
          updateTarget
        ]
      ];else Linkende noch nicht erreicht
      [
        move 
      ]
    ]
  ]
end


to move
  if (cognestion)[
    if longest-cognestion < current-cognestion-time [
      set longest-cognestion current-cognestion-time 
    ]
    set current-cognestion-time 0
  ]
  face nextTarget
  forward .1
  set color blue
  set cognestion false
  set hopCount 1
  set leader true 
end

to stopcar
  if (not cognestion) [
   ; communicate heading
    set cognestion true
    set cognestion-count (cognestion-count + 1)
  ]
  set cognestion-time (cognestion-time + 1) 
  set current-cognestion-time ( current-cognestion-time + 1)
  set color orange
end

to updateTarget
  set lastTarget nextTarget
  set nextTarget one-of [out-link-neighbors] of nextTarget
  diecar
  set street (link-of lastTarget nextTarget)
end

to diecar
  if(nextTarget = nobody) [
      set carcount ( carcount - 1)
      log-car-death lastTarget cognestion-time cognestion-count longest-cognestion birthtime tickcount
      die
  ]
end

;to communicate [myheading]
;  tellJunction
;  ask ( other cars with [heading < myheading + 20 AND heading > myheading - 20] in-cone .5 40 )[
;    set hopCount (hopCount + 1)
;    print hopCount
;    communicate(heading) 
;  ]
;end
;
;to tellJunction
;  if (leader)[
;    ;falls leder = true : setzte cogNr = hopCount
;    ;die junktion 
;    ; let a  street with part_of_junction)
;    let a hopCount
;    ask [part_of_junction] of street
;      [
;        set queue a
;        ;set queuepos [part_of_junction] of street
;      ]   
;  ]  
;end    
;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



to-report nextcors [r phi]
 let x xcor + (r * sin (phi))
 let y ycor + (r * cos (phi))
 report list x y
end

to-report euclidean_distance[x1 y1 x2 y2]
  report sqrt ((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
end

to-report d_euclidean[p1 p2]
  report sqrt ((first p2 - first p1) ^ 2 + (last p2 - last p1) ^ 2)
end

to-report poslst
  report list xcor ycor
end

to-report pos-of [thing]
  report list ([xcor] of thing) ([ycor] of thing)
end

to-report cars-ahead [myheading]
  let c count other cars with [heading < myheading + 20 AND heading > myheading - 20] in-cone .5 40 
  let myxcor xcor
  let myycor ycor
  if (0 < count other cars with [xcor = myxcor and ycor = myycor])[
    set c 0
  ]
  report c 
end 

to-report link-of [lat nt]
  report one-of (links with [end1 = lat]) with [end2 = nt]
;   ([who] of lat) ([who] of nt)
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                      road tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to init-road-test [road]
  if road = "AB" [inittest link  2  3 link  5  6]
  if road = "CD" [inittest link  6  7 link  8  9]
  if road = "EG" [inittest link 40 21 link 23 24]
  if road = "FG" [inittest link 21 22 link 23 24]
  if road = "HI" [inittest link 24 25 link 28 29]
  print word "inisalized mesuring for road: " road
end

to inittest [li lo]
  set Lin li
  set Lout lo
  set mescars 0
  set summestimes 0
end 

to inittestcar
  set mes false
  set fo false
  set it 0
  set ot 0
end

to testline
  if (street = Lin and not mes) [
      set mes true
      set it tickcount
  ]
  if (street = Lout and not fo) [
    set fo true    
  ]
  if (fo and (not (street = Lout))) [
    set ot tickcount
    print (word " mesured travel time = " (ot - it ) " ticks by (" who " " breed ") on road: " test-road) 
    set mes false 
    set fo false
    set summestimes (summestimes + (ot - it))
    set mescars (mescars + 1)
  ]
end
 
  